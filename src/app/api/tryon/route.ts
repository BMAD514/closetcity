import { NextRequest, NextResponse } from 'next/server';
import { r2Put, sha256, generateId } from '@/lib/utils';
import { Env, TryOnRequest, TryOnResponse } from '@/lib/types';
import { getDefaultProvider } from '@/lib/tryon';
import { checkRateLimitEdge } from '../../../lib/ratelimit';
import { getRequestContext } from '@cloudflare/next-on-pages';

export const runtime = 'edge';

export async function POST(request: NextRequest): Promise<NextResponse<TryOnResponse>> {
  try {
    // Get Cloudflare bindings
    const env = getRequestContext().env as Env;
    
    if (!env.DB || !env.R2 || !env.GEMINI_API_KEY) {
      return NextResponse.json(
        { success: false, error: 'Required services not configured', code: 'CONFIG_MISSING', url: '', cached: false, cacheHit: false as boolean },
        { status: 500 }
      );
    }

    // Rate limiting: 10/day per IP (KV if available)
    const rl = await checkRateLimitEdge((env as Env).RL_KV, request as unknown as Request, 10);
    if (rl.exceeded) {
      return NextResponse.json(
        { success: false, error: 'Rate limit exceeded', code: 'RATE_LIMIT', url: '', cached: false, cacheHit: false },
        { status: 429, headers: { 'Retry-After': String(rl.retryAfterSeconds ?? 0) } }
      );
    }

    // Parse request body
    const body: TryOnRequest = await request.json();
    const { modelUrl, garmentUrl, poseKey, layerSig } = body;

    // Validate inputs
    if (!modelUrl || !garmentUrl || !poseKey) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: modelUrl, garmentUrl, poseKey', code: 'BAD_REQUEST', url: '', cached: false, cacheHit: false },
        { status: 400 }
      );
    }

    // Generate deterministic cache key
    const promptVersion = env.PROMPT_VERSION || 'v1';
    const cacheInput = `${promptVersion}|${modelUrl}|${garmentUrl}|${poseKey}|${layerSig || 'base'}`;
    const cacheKey = await sha256(cacheInput);

    // Check cache first
    const cached = await env.DB.prepare(
      'SELECT image_url FROM pose_cache WHERE cache_key = ?'
    ).bind(cacheKey).first();

    if (cached) {
      console.log(`Cache hit for try-on: ${cacheKey}`);
      return NextResponse.json({
        success: true,
        url: cached.image_url as string,
        cached: true,
        cacheHit: true,
      });
    }

    console.log(`Cache miss for try-on: ${cacheKey}, calling provider`);

    // Call provider
    const provider = getDefaultProvider(env.GEMINI_API_KEY);
    const result = await provider.applyGarment(modelUrl, garmentUrl, poseKey);
    if (!result?.dataBase64) {
      return NextResponse.json(
        { success: false, error: 'No image generated by AI', code: 'AI_FAILURE', url: '', cached: false, cacheHit: false },
        { status: 500 }
      );
    }

    // Convert base64 to bytes
    const imageData = atob(result.dataBase64);
    const imageBytes = new Uint8Array(imageData.length);
    for (let i = 0; i < imageData.length; i++) {
      imageBytes[i] = imageData.charCodeAt(i);
    }

    // Upload to R2
    const resultId = generateId();
    const resultKey = `tryon/${resultId}.webp`;
    const resultUrl = await r2Put(env.R2, resultKey, imageBytes, 'image/webp');

    // Cache the result
    await env.DB.prepare(
      'INSERT INTO pose_cache (cache_key, image_url, prompt_version) VALUES (?, ?, ?)'
    ).bind(cacheKey, resultUrl, promptVersion).run();

    console.log(`Generated and cached try-on result: ${resultKey}`);

    return NextResponse.json({
      success: true,
      url: resultUrl,
      cached: false,
      cacheHit: false,
    });

  } catch (error) {
    console.error('Try-on error:', error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Try-on failed',
        code: 'INTERNAL_ERROR',
        url: '',
        cached: false,
        cacheHit: false,
      },
      { status: 500 }
    );
  }
}
