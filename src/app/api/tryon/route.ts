import { NextRequest, NextResponse } from 'next/server';
import { fetchAsBase64, r2Put, sha256, generateId } from '@/lib/utils';
import { TRYON_PROMPT_V1, GEMINI_API_URL, API_TIMEOUT } from '@/lib/constants';
import { Env, TryOnRequest, TryOnResponse, GeminiRequest, GeminiResponse } from '@/lib/types';

export const runtime = 'edge';

export async function POST(request: NextRequest): Promise<NextResponse<TryOnResponse>> {
  try {
    // Get Cloudflare bindings
    const env = process.env as unknown as Env;
    
    if (!env.DB || !env.R2 || !env.GEMINI_API_KEY) {
      return NextResponse.json(
        { success: false, error: 'Required services not configured', url: '', cached: false },
        { status: 500 }
      );
    }

    // Parse request body
    const body: TryOnRequest = await request.json();
    const { modelUrl, garmentUrl, poseKey } = body;

    // Validate inputs
    if (!modelUrl || !garmentUrl || !poseKey) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: modelUrl, garmentUrl, poseKey', url: '', cached: false },
        { status: 400 }
      );
    }

    // Generate deterministic cache key
    const promptVersion = env.PROMPT_VERSION || 'v1';
    const cacheInput = `${promptVersion}|${modelUrl}|${garmentUrl}|${poseKey}`;
    const cacheKey = await sha256(cacheInput);

    // Check cache first
    const cached = await env.DB.prepare(
      'SELECT image_url FROM pose_cache WHERE cache_key = ?'
    ).bind(cacheKey).first();

    if (cached) {
      console.log(`Cache hit for try-on: ${cacheKey}`);
      return NextResponse.json({
        success: true,
        url: cached.image_url as string,
        cached: true,
      });
    }

    console.log(`Cache miss for try-on: ${cacheKey}, calling Gemini API`);

    // Fetch images as base64
    const [modelBase64, garmentBase64] = await Promise.all([
      fetchAsBase64(modelUrl),
      fetchAsBase64(garmentUrl),
    ]);

    // Prepare Gemini API request
    const geminiRequest: GeminiRequest = {
      contents: [
        { text: TRYON_PROMPT_V1 },
        { 
          inlineData: { 
            data: modelBase64, 
            mimeType: 'image/*' 
          } 
        },
        { 
          inlineData: { 
            data: garmentBase64, 
            mimeType: 'image/*' 
          } 
        },
      ],
    };

    // Call Gemini API
    const geminiResponse = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': env.GEMINI_API_KEY,
      },
      body: JSON.stringify(geminiRequest),
      signal: AbortSignal.timeout(API_TIMEOUT),
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      console.error('Gemini API error:', errorText);
      return NextResponse.json(
        { success: false, error: 'AI generation failed', url: '', cached: false },
        { status: 500 }
      );
    }

    const geminiData: GeminiResponse = await geminiResponse.json();

    // Extract generated image
    const candidate = geminiData.candidates?.[0];
    const imagePart = candidate?.content?.parts?.find(part => part.inlineData);

    if (!imagePart?.inlineData?.data) {
      return NextResponse.json(
        { success: false, error: 'No image generated by AI', url: '', cached: false },
        { status: 500 }
      );
    }

    // Convert base64 to ArrayBuffer
    const imageData = atob(imagePart.inlineData.data);
    const imageBytes = new Uint8Array(imageData.length);
    for (let i = 0; i < imageData.length; i++) {
      imageBytes[i] = imageData.charCodeAt(i);
    }

    // Upload to R2
    const resultId = generateId();
    const resultKey = `tryon/${resultId}.webp`;
    const resultUrl = await r2Put(env.R2, resultKey, imageBytes, 'image/webp');

    // Cache the result
    await env.DB.prepare(
      'INSERT INTO pose_cache (cache_key, image_url, prompt_version) VALUES (?, ?, ?)'
    ).bind(cacheKey, resultUrl, promptVersion).run();

    console.log(`Generated and cached try-on result: ${resultKey}`);

    return NextResponse.json({
      success: true,
      url: resultUrl,
      cached: false,
    });

  } catch (error) {
    console.error('Try-on error:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: error instanceof Error ? error.message : 'Try-on failed',
        url: '',
        cached: false,
      },
      { status: 500 }
    );
  }
}
