export const onRequest = async (context: any) => {
  try {
    const { env, request } = context as unknown as { env: any; request: Request };
    if (!env.DB || !env.R2 || !env.GEMINI_API_KEY) {
      return new Response(
        JSON.stringify({ success: false, error: 'Required services not configured', url: '', cached: false, code: 'CONFIG_MISSING' }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const body = await request.json().catch(() => ({}));
    const { modelUrl, poseKey } = body || {};
    if (!modelUrl || !poseKey) {
      return new Response(
        JSON.stringify({ success: false, error: 'Missing required fields: modelUrl, poseKey', url: '', cached: false, code: 'BAD_REQUEST' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const { sha256, generateId, r2Put, fetchAsBase64 } = await import('../../src/lib/utils');
    const { GEMINI_API_URL, API_TIMEOUT, POSE_PROMPT_TEMPLATE } = await import('../../src/lib/constants');

    const promptVersion = env.PROMPT_VERSION || 'v1';
    const cacheInput = `${promptVersion}|${modelUrl}|${poseKey}`;
    const cacheKey = await sha256(cacheInput);

    const cached = await env.DB.prepare('SELECT image_url FROM pose_cache WHERE cache_key = ?').bind(cacheKey).first();
    if (cached) {
      return new Response(JSON.stringify({ success: true, url: cached.image_url as string, cached: true, cacheHit: true }), { headers: { 'Content-Type': 'application/json' } });
    }

    const modelBase64 = await fetchAsBase64(modelUrl);

    const bodyReq = {
      contents: [
        { text: POSE_PROMPT_TEMPLATE(poseKey) },
        { inlineData: { data: modelBase64, mimeType: 'image/*' } },
      ],
    };

    const controller = new AbortController();
    const to = setTimeout(() => controller.abort(), API_TIMEOUT);
    const res = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-goog-api-key': env.GEMINI_API_KEY },
      body: JSON.stringify(bodyReq),
      signal: controller.signal,
    }).finally(() => clearTimeout(to));

    if (!res.ok) {
      const errorText = await res.text();
      console.error('Gemini API error:', errorText);
      return new Response(JSON.stringify({ success: false, error: 'AI generation failed', url: '', cached: false, code: 'AI_FAILURE' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
    }

    const json = await res.json();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const part = json?.candidates?.[0]?.content?.parts?.find((p: any) => p.inlineData);
    const dataBase64: string | undefined = part?.inlineData?.data;
    if (!dataBase64) {
      return new Response(JSON.stringify({ success: false, error: 'No image generated by AI', url: '', cached: false, code: 'AI_FAILURE' }), { status: 500, headers: { 'Content-Type': 'application/json' } });
    }

    const bin = atob(dataBase64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);

    const resultId = generateId();
    const resultKey = `pose/${resultId}.webp`;
    const resultUrl = await r2Put(env.R2, resultKey, bytes, 'image/webp');

    await env.DB.prepare('INSERT INTO pose_cache (cache_key, image_url, prompt_version) VALUES (?, ?, ?)')
      .bind(cacheKey, resultUrl, promptVersion)
      .run();

    return new Response(JSON.stringify({ success: true, url: resultUrl, cached: false, cacheHit: false }), { headers: { 'Content-Type': 'application/json' } });
  } catch (error) {
    console.error('Pose error:', error);
    return new Response(
      JSON.stringify({ success: false, error: error instanceof Error ? error.message : 'Pose failed', url: '', cached: false, code: 'INTERNAL_ERROR' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
};

