export const onRequest = async (context: any) => {
  try {
    const { env, request, waitUntil } = context as unknown as { env: any; request: Request; waitUntil: (p: Promise<any>) => void };

    // CORS preflight support
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
        },
      });
    }
    if (!env.DB || !env.R2 || !env.GEMINI_API_KEY) {
      return new Response(
        JSON.stringify({ success: false, error: 'Required services not configured', code: 'CONFIG_MISSING' }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const body = await request.json().catch(() => ({}));
    const userImageUrl: string | undefined = body?.userImageUrl;
    const preferAsync: boolean = !!body?.async || request.headers.get('x-async') === '1' || new URL(request.url).searchParams.get('async') === '1';
    if (!userImageUrl) {
      return new Response(
        JSON.stringify({ success: false, error: 'Missing required field: userImageUrl', code: 'BAD_REQUEST' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const { sha256, generateId, r2Put, fetchAsBase64 } = await import('../../src/lib/utils');
    const { GEMINI_API_URL, API_TIMEOUT } = await import('../../src/lib/constants');

    const promptVersion = env.PROMPT_VERSION || 'v1';
    const cacheInput = `${promptVersion}|${userImageUrl}`;
    const cacheKey = await sha256(cacheInput);

    // Cache hit â†’ return immediately (supports both sync and async callers)
    const cached = await env.DB.prepare('SELECT image_url FROM model_cache WHERE cache_key = ?').bind(cacheKey).first();
    if (cached) {
      if (preferAsync) {
        const jobId = await ensureJobForCache(env, 'model', cacheKey, { userImageUrl }, cached.image_url as string);
        { const site = new URL(request.url).origin; return json({ jobId, status: 'succeeded', output: { url: ((cached.image_url as string).startsWith('http') ? cached.image_url : site + (cached.image_url as string)) }, cacheHit: true }); }
      }
      { const site = new URL(request.url).origin; const full = ((cached.image_url as string).startsWith('http') ? cached.image_url : site + (cached.image_url as string)); return json({ success: true, url: full, cached: true, cacheHit: true }); }
    }

    if (preferAsync) {
      if (!env.JOBS) return json({ error: 'JOBS KV binding is not configured' }, 500);
      // Deduplicate by cacheKey
      const existingJobId = await env.JOBS.get(`jobByCache:${cacheKey}`);
      if (existingJobId) return json({ jobId: existingJobId, status: 'queued' });

      const jobId = generateId();
      const job = {
        id: jobId,
        type: 'model' as const,
        status: 'queued' as const,
        cacheKey,
        attempts: 0,
        input: { userImageUrl, promptVersion },
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };
      await env.JOBS.put(`job:${jobId}`, JSON.stringify(job));
      await env.JOBS.put(`jobByCache:${cacheKey}`, jobId);

      waitUntil(processModelJob(env, jobId));
      return json({ jobId, status: 'queued' });
    }

    // Synchronous path (temporary for backward compat)
    const userBase64 = await fetchAsBase64(userImageUrl);
    const { MODEL_PROMPT_V2 } = await import('../../src/lib/constants');

    const bodyReq = {
      contents: [
        { text: MODEL_PROMPT_V2 },
        { inlineData: { data: userBase64, mimeType: 'image/*' } },
      ],
    };

    const controller = new AbortController();
    const to = setTimeout(() => controller.abort(), API_TIMEOUT);
    const res = await fetch(GEMINI_API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'x-goog-api-key': env.GEMINI_API_KEY },
      body: JSON.stringify(bodyReq),
      signal: controller.signal,
    }).finally(() => clearTimeout(to));

    if (!res.ok) {
      const errorText = await res.text();
      console.error('Gemini API error:', errorText);
      return json({ success: false, error: 'AI generation failed', code: 'AI_FAILURE' }, 500);
    }

    const jsonResp = await res.json();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const part = jsonResp?.candidates?.[0]?.content?.parts?.find((p: any) => p.inlineData);
    const dataBase64: string | undefined = part?.inlineData?.data;
    if (!dataBase64) return json({ success: false, error: 'No image generated by AI', code: 'AI_FAILURE' }, 500);

    const bin = atob(dataBase64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);

    const resultId = generateId();
    const resultKey = `model/${resultId}.webp`;
    const resultUrl = await r2Put(env.R2, resultKey, bytes, 'image/webp');
    const site = new URL(request.url).origin;
    const full = resultUrl.startsWith('http') ? resultUrl : site + resultUrl;

    await env.DB.prepare('INSERT INTO model_cache (cache_key, image_url, prompt_version) VALUES (?, ?, ?)')
      .bind(cacheKey, resultUrl, promptVersion)
      .run();

    return json({ success: true, url: full, cached: false, cacheHit: false });
  } catch (error) {
    console.error('Model generate error:', error);
    return json({ success: false, error: error instanceof Error ? error.message : 'Model generation failed', code: 'INTERNAL_ERROR' }, 500);
  }
};

function json(obj: any, status = 200) {
  return new Response(JSON.stringify(obj), {
    status,
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': 'no-store',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET,POST,OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
    },
  });
}

async function ensureJobForCache(env: any, type: string, cacheKey: string, input: any, url: string) {
  const { generateId } = await import('../../src/lib/utils');
  const existingJobId = await env.JOBS?.get(`jobByCache:${cacheKey}`);
  if (existingJobId) return existingJobId;
  const jobId = generateId();
  const job = { id: jobId, type, status: 'succeeded', cacheKey, input, output: { url }, attempts: 0, cached: true, createdAt: Date.now(), updatedAt: Date.now() };
  await env.JOBS?.put(`job:${jobId}`, JSON.stringify(job));
  await env.JOBS?.put(`jobByCache:${cacheKey}`, jobId);
  return jobId;
}

async function processModelJob(env: any, jobId: string) {
  try {
    const raw = await env.JOBS.get(`job:${jobId}`);
    if (!raw) return;
    const job = JSON.parse(raw);
    if (job.status !== 'queued') return;
    job.status = 'processing'; job.attempts++; job.updatedAt = Date.now();
    await env.JOBS.put(`job:${jobId}`, JSON.stringify(job));

    const { fetchAsBase64, generateId, r2Put } = await import('../../src/lib/utils');
    const { MODEL_PROMPT_V2, GEMINI_API_URL, API_TIMEOUT } = await import('../../src/lib/constants');

    const userBase64 = await fetchAsBase64(job.input.userImageUrl);
    const bodyReq = { contents: [ { text: MODEL_PROMPT_V2 }, { inlineData: { data: userBase64, mimeType: 'image/*' } } ] };

    const controller = new AbortController();
    const to = setTimeout(() => controller.abort(), API_TIMEOUT);
    const res = await fetch(GEMINI_API_URL, {
      method: 'POST', headers: { 'Content-Type': 'application/json', 'x-goog-api-key': env.GEMINI_API_KEY },
      body: JSON.stringify(bodyReq), signal: controller.signal,
    }).finally(() => clearTimeout(to));

    if (!res.ok) throw new Error(`Gemini API failed: ${await res.text()}`);
    const jsonResp = await res.json();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const part = jsonResp?.candidates?.[0]?.content?.parts?.find((p: any) => p.inlineData);
    const dataBase64: string | undefined = part?.inlineData?.data;
    if (!dataBase64) throw new Error('No image generated');

    const bin = atob(dataBase64);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);

    const resultId = generateId();
    const resultKey = `model/${resultId}.webp`;
    const resultUrl = await r2Put(env.R2, resultKey, bytes, 'image/webp');

    await env.DB.prepare('INSERT INTO model_cache (cache_key, image_url, prompt_version) VALUES (?, ?, ?)')
      .bind(job.cacheKey, resultUrl, job.input.promptVersion)
      .run();

    job.status = 'succeeded'; job.output = { url: resultUrl }; job.updatedAt = Date.now();
    await env.JOBS.put(`job:${jobId}`, JSON.stringify(job));
  } catch (e: any) {
    const raw = await env.JOBS.get(`job:${jobId}`);
    if (!raw) return;
    const job = JSON.parse(raw);
    job.status = 'failed'; job.error = e?.message || 'Job failed'; job.updatedAt = Date.now();
    await env.JOBS.put(`job:${jobId}`, JSON.stringify(job));
  }
}

